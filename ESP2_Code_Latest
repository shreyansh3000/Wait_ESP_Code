#define TINY_GSM_MODEM_SIM7600
#define TINY_GSM_DEBUG        Serial

/* ---------------- libraries ------------------------------------- */
#include <TinyGSM.h>                  // 0.12.0 or later
#include <ArduinoHttpClient.h>        // arduino-libraries/ArduinoHttpClient
#include <ArduinoJson.h>              // >= 6.21
#include "SSLClient.h"                // govorov/SSLClient 1.3.x
#include "utilities.h"                // ‚Üê your helper header
#include "certs.h"                    // root CA (swap setInsecure in prod)

/* ---------------- board / carrier parameters -------------------- */
const char apn[]      = "airtelgprs.com";
const char server[]   = "starfish-app-2-u7j2r.ondigitalocean.app";
const char resource[] = "/insert";
const int  port       = 443;

/* ---------------- IO pins & constants --------------------------- */
#define MODEM_TX     17
#define MODEM_RX     16
#define MODEM_PWRKEY 26
#define MODEM_RESET  27
#define UART_BAUD    115200    // Keep modem at 115200 for stability

#define TIME_TO_SLEEP 30

#define SerialMon Serial
#define SerialAT  Serial1
HardwareSerial EspSerial(2);

/* ---------------- Updated payload structure to match ESP1 ------------------------------- */
struct Payload {
  char device[20];
  char type[10];
  int count;
  float speed;
  int setvalue;
  int num;
} __attribute__((packed));
static_assert(sizeof(Payload) == 46, "Payload layout mismatch!");

TinyGsm       modem(SerialAT);
TinyGsmClient baseClient(modem, 0);
SSLClient     secure_layer(&baseClient);
HttpClient    client(secure_layer, server, port);

constexpr uint8_t  MAX_HTTP_RETRIES      = 3;
constexpr uint32_t TCP_CONNECT_TO_MS     = 20000;
constexpr uint32_t TLS_RW_TO_MS          = 7000;
constexpr uint32_t HTTP_RESP_TO_MS       = 7000;

bool initModemOnce();
bool ensurePdp();
void configureHttpLayer();
bool postJson(const Payload& p);
void light_sleep(uint32_t sec);
void flushUART2();
bool readCompletePayload(Payload* pkt);
bool validatePayload(const Payload& p);

void setup()
{
  SerialMon.begin(115200);  // Keep SerialMon at 115200 for clear output
  delay(100);
  
  SerialMon.println(F("=== ESP2 Starting ==="));

  // Initialize serial communications
  SerialAT.begin(UART_BAUD, SERIAL_8N1, MODEM_RX, MODEM_TX);  // Modem at 115200
  EspSerial.begin(19200, SERIAL_8N1, 14, 12);  // ESP1 communication at 19200
  EspSerial.setTimeout(1000);

  SerialMon.printf("Free heap at start: %d bytes\n", ESP.getFreeHeap());
  SerialMon.printf("Expected payload size: %d bytes\n", sizeof(Payload));

  // Initialize modem control pins
  pinMode(MODEM_RESET, OUTPUT);  
  digitalWrite(MODEM_RESET, HIGH);
  pinMode(MODEM_PWRKEY, OUTPUT); 
  digitalWrite(MODEM_PWRKEY, HIGH);
  delay(300);                    
  digitalWrite(MODEM_PWRKEY, LOW);

  // Configure SSL (insecure for testing)
  secure_layer.setInsecure();

  // Initialize modem
  if (!initModemOnce()) {
    SerialMon.println(F("‚ùå Modem init failed ‚Äì halting"));
    for (;;) { delay(1000); }
  }

  configureHttpLayer();
  SerialMon.println(F("‚úÖ Receiver ready"));
}

void loop()
{
  // Handle incoming data from ESP1
  if (EspSerial.available() >= sizeof(Payload)) {
    Payload pkt;
    
    if (readCompletePayload(&pkt)) {
      SerialMon.printf("üì¶ Received: dev='%s' type='%s' speed=%.2f count=%d set=%d num=%d\n",
                       pkt.device, pkt.type, pkt.speed, pkt.count, pkt.setvalue, pkt.num);
      
      if (validatePayload(pkt)) {
        // Send data to cloud if we have meaningful data
        if (pkt.speed > 0 || pkt.count > 0) {
          if (postJson(pkt)) {
            SerialMon.println("‚úÖ Data sent to cloud successfully");
          } else {
            SerialMon.println("‚ùå Failed to send data to cloud");
          }
        }
        
        // Handle communication back to ESP1 if needed
        if (pkt.setvalue == 3 && pkt.num > 0) {
          SerialMon.printf("üì§ Sending ACK to ESP1 for num=%d\n", pkt.num);
          
          // Create response packet
          Payload response;
          memset(&response, 0, sizeof(response));
          strncpy(response.device, "ESP2", sizeof(response.device) - 1);
          strncpy(response.type, "ACK", sizeof(response.type) - 1);
          response.setvalue = 0;
          response.num = pkt.num;
          
          // Send response back to ESP1
          EspSerial.write((uint8_t*)&response, sizeof(response));
          SerialMon.println("‚úÖ ACK sent to ESP1");
        }
      } else {
        SerialMon.println("‚ùå Invalid payload, discarding");
        flushUART2();
      }
    } else {
      SerialMon.println("‚ùå Failed to read complete payload");
      flushUART2();
    }
  }
  
  delay(10); // Small delay to prevent system overload
}

bool readCompletePayload(Payload* pkt)
{
  if (!pkt) return false;
  
  memset(pkt, 0, sizeof(Payload)); // Clear the structure
  
  size_t totalBytesRead = 0;
  unsigned long startTime = millis();
  const unsigned long timeout = 2000; // 2 second timeout
  
  while (totalBytesRead < sizeof(Payload) && (millis() - startTime) < timeout) {
    if (EspSerial.available()) {
      size_t bytesToRead = sizeof(Payload) - totalBytesRead;
      size_t available = EspSerial.available();
      
      if (available < bytesToRead) {
        bytesToRead = available;
      }
      
      size_t bytesRead = EspSerial.readBytes(
        reinterpret_cast<uint8_t*>(pkt) + totalBytesRead, 
        bytesToRead
      );
      
      totalBytesRead += bytesRead;
      
      if (totalBytesRead < sizeof(Payload)) {
        delay(5); // Small delay to allow more data to arrive
      }
    } else {
      delay(1);
    }
  }
  
  bool success = (totalBytesRead == sizeof(Payload));
  if (!success) {
    SerialMon.printf("‚ùå Incomplete read: %u/%u bytes\n", totalBytesRead, sizeof(Payload));
  }
  
  return success;
}

bool validatePayload(const Payload& p)
{
  // Check for reasonable speed values
  if (p.speed < -1.0 || p.speed > 300.0) {
    SerialMon.printf("‚ùå Invalid speed: %.2f\n", p.speed);
    return false;
  }
  
  // Check for reasonable count values
  if (p.count < 0 || p.count > 10000) {
    SerialMon.printf("‚ùå Invalid count: %d\n", p.count);
    return false;
  }
  
  // Check device string (should be null-terminated within bounds)
  bool deviceValid = false;
  for (int i = 0; i < 20; i++) {
    if (p.device[i] == '\0') {
      deviceValid = true;
      break;
    }
  }
  if (!deviceValid) {
    SerialMon.println("‚ùå Invalid device string");
    return false;
  }
  
  // Check type string (should be null-terminated within bounds)
  bool typeValid = false;
  for (int i = 0; i < 10; i++) {
    if (p.type[i] == '\0') {
      typeValid = true;
      break;
    }
  }
  if (!typeValid) {
    SerialMon.println("‚ùå Invalid type string");
    return false;
  }
  
  return true;
}

void configureHttpLayer()
{
  baseClient.setTimeout(TCP_CONNECT_TO_MS);
  secure_layer.setTimeout(TLS_RW_TO_MS);
  secure_layer.setHandshakeTimeout(TCP_CONNECT_TO_MS / 1000);
  client.setHttpResponseTimeout(HTTP_RESP_TO_MS);
  client.connectionKeepAlive();
}

bool initModemOnce()
{
  SerialMon.println(F("Initializing modem‚Ä¶"));
  if (!modem.init() && !modem.restart()) return false;

  for (uint8_t i = 0; i < 5; ++i) {
    if (modem.setNetworkMode(54)) break;
    delay(500);
  }

  SerialMon.println(F("Waiting for network‚Ä¶"));
  if (!modem.waitForNetwork(300000UL)) return false;

  if (!modem.gprsConnect(apn, "", "")) return false;

  SerialMon.print(F("PDP attached. IP=")); 
  SerialMon.println(modem.localIP());
  modem.sendAT("+CPSMS=0");
  modem.sendAT("+CEDRXS=0");
  return true;
}

bool ensurePdp()
{
  if (modem.isGprsConnected()) return true;

  SerialMon.println(F("PDP down ‚Äì re‚Äëattaching‚Ä¶"));
  modem.gprsDisconnect();

  for (uint8_t i = 0; i < 5; ++i) {
    if (modem.gprsConnect(apn, "", "")) {
      SerialMon.print(F("Re‚Äëattached. IP=")); 
      SerialMon.println(modem.localIP());
      return true;
    }
    delay(100);
  }
  SerialMon.println(F("Re‚Äëattach failed"));
  return false;
}

bool postJson(const Payload& p)
{
  DynamicJsonDocument doc(256);
  doc["unit"]      = String(p.device);      // Ensure proper string conversion
  doc["type"]      = String(p.type);        // Ensure proper string conversion
  doc["speed"]     = roundf(p.speed * 100) / 100;  // Round to 2 decimal places
  doc["count"]     = p.count;
  doc["timestamp"] = modem.getGSMDateTime(DATE_FULL);

  // Validation with reasonable ranges
  if (p.speed < 0 || p.speed > 250 || p.count > 1000 || p.count < 0) {
    SerialMon.println("‚ùå Data validation failed, restarting modem");
    modem.restart();
    initModemOnce();
    flushUART2();
    return false;
  }

  String body;
  size_t jsonSize = serializeJson(doc, body);
  
  if (jsonSize == 0) {
    SerialMon.println("‚ùå JSON serialization failed");
    return false;
  }

  for (uint8_t attempt = 1; attempt <= MAX_HTTP_RETRIES; ++attempt) {
    if (!ensurePdp()) {
      SerialMon.println(F("No PDP ‚Äì give up this attempt"));
      delay(1000);
      continue;
    }

    // Clean up connections
    client.stop(); 
    secure_layer.stop(); 
    baseClient.stop();
    delay(100);

    SerialMon.printf("üì° POST %s%s (%u B) attempt %u/%u\n",
                     server, resource, body.length(), attempt, MAX_HTTP_RETRIES);

    if (client.post(resource, F("application/json"), body) != 0) {
      SerialMon.println(F("‚úó failed to send request headers"));
      delay(1000);
      continue;
    }

    // Wait for response with timeout
    unsigned long responseStart = millis();
    int status = 0;
    
    while (status == 0 && (millis() - responseStart) < HTTP_RESP_TO_MS) {
      status = client.responseStatusCode();
      if (status == 0) {
        delay(100);
      }
    }

    SerialMon.printf("‚Ü¶ HTTP %d\n", status);

    if (status >= 200 && status < 300) {
      String response = client.responseBody();
      SerialMon.printf("‚úÖ Success: %s\n", response.c_str());
      client.stop();
      return true;
    } else if (status == 0) {
      SerialMon.println("‚ùå Response timeout");
    } else {
      SerialMon.printf("‚ùå HTTP error: %d\n", status);
    }

    client.stop();
    delay(attempt * 1000); // Increasing delay between retries
  }

  SerialMon.println(F("üö® all retries exhausted"));
  modem.restart();
  initModemOnce();
  flushUART2();
  return false;
}

void flushUART2() {
  SerialMon.print(F("üßπ Flushing UART2... "));
  int flushed = 0;
  while (EspSerial.available()) {
    EspSerial.read();
    flushed++;
  }
  SerialMon.printf("flushed %d bytes\n", flushed);
}

void light_sleep(uint32_t sec)
{
  esp_sleep_enable_timer_wakeup(uint64_t(sec) * 1'000'000ULL);
  esp_light_sleep_start();
}
